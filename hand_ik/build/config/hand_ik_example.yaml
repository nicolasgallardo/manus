# Hand IK Configuration Example
# Modify these settings to match your specific robotic hand URDF

# Joint names - these must exactly match the joint names in your URDF
joint_names:
  mcp_joints:
    - "Index_MCP_Joint"      # Index finger MCP (metacarpophalangeal) joint
    - "Middle_MCP_Joint"     # Middle finger MCP joint  
    - "Ring_MCP_Joint"       # Ring finger MCP joint
    - "Pinky_MCP_Joint"      # Pinky finger MCP joint
  
  distal_joints:
    - "Index_PIP_Joint"      # Index finger PIP joint (passive, corresponds to distal)
    - "Middle_PIP_Joint"     # Middle finger PIP joint (passive)
    - "Ring_PIP_Joint"       # Ring finger PIP joint (passive)
    - "Pinky_PIP_Joint"      # Pinky finger PIP joint (passive)
  
  thumb_joints:
    rotation: "Metacarpal_Joint"    # Thumb metacarpal rotation (ab/adduction)
    flexion: "Thumb_Joint"          # Thumb flexion joint

# Frame names - since no explicit tip frames exist in URDF, we'll use the distal link names
frame_names:
  fingertips:
    - "Index_Distal"         # Index fingertip (using distal link as frame)
    - "Middle_Distal"        # Middle fingertip (using distal link as frame)
    - "Ring_Distal"          # Ring fingertip (using distal link as frame)
    - "Pinky_Distal"         # Pinky fingertip (using distal link as frame)
  
  thumb_tip: "Thumb"             # Thumb tip (using thumb link as frame)

# Passive joint coupling coefficients
# Each distal joint angle is computed as: q_distal = a*q_mcp^3 + b*q_mcp^2 + c*q_mcp + d
# These coefficients are based on measured data from the actual hand mechanism
passive_coupling:
  index:
    a: 0.0124      # Cubic coefficient (from measured data)
    b: 0.0        # Quadratic coefficient (simplified from 4th order fit)
    c: 0.622       # Linear coefficient (dominant term)
    d: 3.0025      # Constant offset (degrees converted to radians: ~0.0524)
  
  middle:
    a: 0.0124      # Same coupling mechanism for all fingers
    b: 0.0
    c: 0.622
    d: 3.0025
  
  ring:
    a: 0.0124      # Same coupling mechanism for all fingers  
    b: 0.0
    c: 0.622
    d: 3.0025
  
  pinky:
    a: 0.0124      # Same coupling mechanism for all fingers
    b: 0.0
    c: 0.622
    d: 3.0025

# Joint limits in radians [lower_limit, upper_limit]
joint_limits:
  mcp_joints:
    index: [0.0, 1.774]       # Index MCP limits (from URDF)
    middle: [0.0, 1.774]      # Middle MCP limits  
    ring: [0.0, 1.774]        # Ring MCP limits
    pinky: [0.0, 1.774]       # Pinky MCP limits
  
  thumb_joints:
    rotation: [0.0, 1.774]    # Thumb rotation limits (from URDF)
    flexion: [0.0, 1.774]     # Thumb flexion limits (from URDF)

# Solver parameters
solver:
  max_iterations: 100              # Maximum number of iterations
  residual_tolerance: 1.0e-6       # Convergence tolerance for residual norm
  step_tolerance: 1.0e-8           # Convergence tolerance for step size
  damping_initial: 1.0e-6          # Initial damping parameter for Levenberg-Marquardt
  damping_factor: 10.0             # Factor to increase/decrease damping
  line_search_factor: 0.8          # Factor for line search step reduction
  max_line_search_steps: 10        # Maximum line search iterations

# Weights and tolerances
weights:
  fingers:
    index: 1.0     # Weight for index finger position error
    middle: 1.0    # Weight for middle finger position error
    ring: 1.0      # Weight for ring finger position error
    pinky: 1.0     # Weight for pinky finger position error
  
  thumb:
    position: 1.0              # Weight for thumb position error
    orientation: 0.1           # Weight for thumb orientation error

tolerances:
  plane_tolerance: 0.01        # Tolerance for out-of-plane detection (meters)

# Diagnostic settings
diagnostics:
  verbose: false               # Enable verbose output during solving
  jacobian_fd_tolerance: 1.0e-5    # Tolerance for finite difference Jacobian check
  reachability_tests: 100          # Number of tests for reachability validation
  reachability_noise: 0.1          # Noise scale for reachability testing

# Example target configuration for testing
# These values are used by the example program to demonstrate the solver
example_targets:
  fingers:
    # Target positions in meters [x, y, z] in world frame
    index: [0.15, 0.05, 0.12]    # Index finger target position
    middle: [0.16, 0.02, 0.14]   # Middle finger target position  
    ring: [0.15, -0.02, 0.13]    # Ring finger target position
    pinky: [0.13, -0.05, 0.11]   # Pinky finger target position
  
  thumb:
    position: [0.08, 0.08, 0.10]    # Thumb target position
    # Optional: specify target orientation as rotation matrix or quaternion
    # If not specified, only position will be controlled
    use_orientation: false

# Notes:
# 1. All angles are in radians
# 2. All positions are in meters  
# 3. The passive coupling coefficients are based on measured data from your hand
#    Original Excel equation: y = -7E-05xâ´ + 0.0124xÂ³ + 0.622x + 3.0025 (degrees)
#    Simplified to cubic and converted to radians for use in the solver
# 4. Joint limits should include safety margins
# 5. Frame names must exist in your URDF file
# 6. The solver assumes that positive joint angles correspond to flexion
# 7. The measured data shows a strong linear relationship (c=0.622) with cubic nonlinearity